package io.netty.test.test05;import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import java.net.InetSocketAddress;public class ExampleServerBootstrap {    public static void main(String[] args) {//1. EventLoopGroup ≈≈ ThreadPool ExecutorService 接口EventLoopGroup group = new NioEventLoopGroup(Runtime.getRuntime().availableProcessors() + 1);// 创建要给新的 ServerBootstrap 来创建新的 SocketChannel 管道并绑定他们ServerBootstrap bootstrap = new ServerBootstrap();try {    // 指定 EventLoopGroup 用于从注册的 ServerChannel 中获取EventLoop 和接收到的管道    bootstrap.group(group)             .channel(NioServerSocketChannel.class) //指定要使用的管道类             .childHandler(new SimpleChannelInboundHandler<ByteBuf>() { //设置子处理器用于处理接收的管道的 I/O 和数据                 @Override                 protected void channelRead0(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {                     System.out.println("Reveived data");                     byteBuf.clear();                 }             });    // 通过配置引导来绑定管道    ChannelFuture future = bootstrap.bind(new InetSocketAddress(8080));    future.addListener(new ChannelFutureListener() {        @Override        public void operationComplete(ChannelFuture future) throws Exception {            if (future.isSuccess()) {                System.out.println("Server bound");            } else {                System.err.println("Bound attempt failed");                future.cause().printStackTrace();            }        }    });} finally {}    }}
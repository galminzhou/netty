package io.netty.test.test01.server;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;/** * 1) ChannelHandler 是给不同类型的事件调用； * 2) 应用程序实现或扩展 ChannelHandler 挂接到事件生命周期和提供自定义应用逻辑。 */@ChannelHandler.Sharable /** Sharable: 标识此类可在Channel共享 */public class EchoServerHandler extends ChannelInboundHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        if (msg instanceof ByteBuf) {            ByteBuf in = (ByteBuf) msg;            System.out.println("ByteBuf hasArray: " + in.hasArray());            // 输出日志消息            System.out.println("Server received: " + in.toString(CharsetUtil.UTF_8));            // 将接收到的消息返回给发送者；            ctx.write(in);        } else {            System.err.println("Error!");        }    }    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {        // 冲刷所有待审核的消息到远程节点，关闭通道后，操作完成        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);    }    /******     * 覆盖 exceptionCaught 使我们能够应对任何 Throwable的子类型。     * 在这种情况下我们记录，并关闭所有可能处于未知状态的连接。 它通常是难以从连接错误中恢复，所以干脆关闭远程连接。     * 当然，也有可能的情况是可以从错误中恢复的，所以可以用一个更复杂的措施来尝试识别和处理 这样的情况。     *     * 每一个Channel都有关联一个ChannelPipeline，它代表了ChannelHandler 实例的链；     * 适配器处理的实现只是将一个处理方法调用转发到链中的下一个处理器。     * 因此，如果一个Netty应用程序不覆盖 exceptionCaught，     * 那么这些错误将最终到达 channelPipeline，并且结束警告将被记录。     * 出于此原因，应该提供至少一个 实现exceptionCaught 的ChannelHandler。     */    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        // 打印异常堆栈信息        cause.printStackTrace();        // 关闭通道        ctx.close();    }}
package io.netty.test.test01.server;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import java.net.InetSocketAddress;public class EchoServer {    private final int port;    public EchoServer(int port) {        this.port = port;    }    /**     * 1) 创建 ServerBootstrap 实例来引导服务器并随后绑定     * 2) 创建并分配一个 NioEventLoopGroup 实例来处理事件的处理，如接受新的连接和读/写数据。     * 3) 指定本地 InetSocketAddress 给服务器绑定     * 4) 通过 EchoServerHandler 实例给每一个新的 Channel 初始化     * 5) 最后调用 ServerBootstrap.bind() 绑定服务器     */    public static void main(String[] args) throws Exception {        if (args.length != 1) {            System.err.println("Usage: " + EchoServer.class.getSimpleName() + " <port>");            return;        }        // 设置端口        int port = Integer.parseInt(args[0]);        new EchoServer(port).start();    }    public void start() throws Exception{        // 指定 NioEventLoopGroup 接受和处理新连接；        NioEventLoopGroup group = new NioEventLoopGroup();        try {            ServerBootstrap bootstrap = new ServerBootstrap();            bootstrap.group(group)                     // 指定 NioServerSocketChannel 为信道类型                     .channel(NioServerSocketChannel.class)                     // 设置本地地址是 InetSocketAddress + 端口port，服务器将绑定到此地址来监听新的连接请求                     .localAddress(new InetSocketAddress(this.port))                     // ChannelInitializer：当一个新的连接被接受，一个新的子 Channel 将被创建，                     // ChannelInitializer 会添加 定义的EchoServerHandler 的实例到 Channel 的 ChannelPipeline。                     .childHandler(new ChannelInitializer<SocketChannel>() {                         @Override                         protected void initChannel(SocketChannel ch) throws Exception {                             ch.pipeline().addLast(new EchoServerHandler());                         }                     });            // bind 绑定服务器，sync 等待服务器关闭            ChannelFuture future = bootstrap.bind().sync();            System.out.println(EchoServer.class.getName() + " started and listen on " + future.channel().localAddress());            future.channel().closeFuture().sync();        } finally {            group.shutdownGracefully().sync();        }    }}